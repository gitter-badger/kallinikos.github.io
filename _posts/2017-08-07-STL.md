---
title: "STL"
layout: post
tags: [STL δομές_δεδομένων ]
category: 4
comments: true
---

Standard Template Library (STL)

* TOC
{:toc}

## Σχέση της C με την C++

Θα ξεκινήσουμε αυτήν την παράγραφο με μια εισαγωγή σχετικά με την σχέση μεταξύ C και C++. Μπορούμε άτυπα να χωρίσουμε την C++ σε δύο μέρη, τα οποία θα ονομάζουμε συναρτησιακό και αντικειμενοστραφές μέρος. Μέχρι στιγμής, έχουμε ασχοληθεί στο κεφάλαιο 2 μόνο με το συναρτησιακό μέρος. Ο όρος «συναρτησιακός προγραμματισμός» προκύπτει από την χρήση συναρτήσεων και τελεστών (που είναι και αυτοί συναρτήσεις) σχεδόν σε κάθε γραμμή των προγραμμάτων μας.
Η σχέση που συνδέει τις δύο γλώσσες C και C++ είναι σχέση εξέλιξης, διότι η C++ είναι ουσιαστικά η μετεξέλιξη της C. Δηλαδή, η C++ προέκυψε από την συναρτησιακή γλώσσα προγραμματισμού C με προσθήκη του αντικειμενοστραφούς μέρους. Η γλώσσα C φυσικά υπάρχει αυτούσια και χρησιμοποιείται ευρέως, ενώ μάλιστα ό,τι μάθαμε στο κεφάλαιο 2 ισχύει κανονικά και στην γλώσσα C, με ελάχιστες εξαιρέσεις. Επομένως μέχρι στιγμής γνωρίζεις να προγραμματίζεις με δύο γλώσσες, την C και την C++! Αλήθεια, δοκίμασε να γράψεις ένα πρόγραμμα σε C!

#### standard βιβλιοθήκες
Όπως ξέρουμε η γλώσσα C++ (και η C) περιέχει ελάχιστες εντολές. Η λειτουργικότητα και το πλήθος των δυνατοτήτων της εξασφαλίζεται μέσω των βιβλιοθηκών που περιέχουν έτοιμες συναρτήσεις. Τέτοιες βιβλιοθήκες μπορούν να δημιουργηθούν από τον καθένα, με βάση τις ήδη υπάρχουσες. Για να τις χρησιμοποιήσει ένας άλλος προγραμματιστής πρέπει να τις προμηθευτεί και να τις εγκαταστήσει στο προγραμματιστικό του περιβάλλον. Για να υπάρχει όμως ένα κοινό πλαίσιο αναφοράς και δυνατοτήτων, η C και η C++ συνοδεύονται πάντα από τις standard βιβλιοθήκες τους.
Καθώς όμως η C++ είναι η μετεξέλιξη της C και το συναρτησιακό κομμάτι της C++ ταυτίζεται με την γλώσσα C, μπορούμε να χρησιμοποιήσουμε σε ένα πρόγραμμα C++ και τις βιβλιοθήκες της C! Σε κάθε λοιπόν προγραμματιστικό περιβάλλον C++ είναι διαθέσιμες οι standard βιβλιοθήκες της C και της C++. Αυτό όμως δεν ισχύει ανάποδα, δηλαδή σε προγραμματιστικό περιβάλλον C είναι διαθέσιμες μόνο οι βιβλιοθήκες της C. Για να συμπεριλάβουμε μια βιβλιοθήκη χρησιμοποιούμε την εντολή #include. Για να συμπεριλάβουμε μια βιβλιοθήκη της c πρέπει να βάλουμε ένα μικρό c μπροστά από το όνομα της:
{% highlight c++ %}
#include <cstdio> //βιβλιοθήκη stdio
#include <cmath>	//βιβλιοθήκη math
{% endhighlight %}
Για να συμπεριλάβουμε μια βιβλιοθήκη της C++ χρησιμοποιούμε την ίδια σύνταξη, χωρίς όμως το μικρό c.
{% highlight c++ %}
#include <algorithm>
#include <iostream>
using namespace std;
{% endhighlight %}
Πρόσεξε ότι μαζί με τις δηλώσεις των βιβλιοθηκών γράψαμε και την εντολή using namespace std; Όλο το περιεχόμενο των βιβλιοθηκών της C++ βρίσκεται δηλωμένο μέσα στο namespace std. Αυτό γίνεται για διάφορους λόγους που ξεφεύγουν από τους σκοπούς αυτού του βιβλίου. Με την εντολή αυτή δηλώνουμε ότι θα χρησιμοποιούμε σε όλο μας το πρόγραμμα τα περιεχόμενα των βιβλιοθηκών της C++ που δηλώσαμε.
Η standard βιβλιοθήκες των C και C++ είναι αχανείς. Εμείς όμως θα χρησιμοποιούμε ένα μικρό μέρος αυτών. Σου προτείνω να ανατρέξεις στο εγχειρίδιο της standard βιβλιοθήκης της C++ για να εντοπίσεις μόνος σου τις βιβλιοθήκες που είναι χρήσιμες για εσένα.
## STL
H standard βιβλιοθήκη της C++ ονομάζεται STL, συντομογραφία για το standard template library. Καθώς το επιπλέον μέρος που διαθέτει η C++ αλλά όχι η C είναι ο αντικειμενοστραφής προγραμματισμός, είναι λογικό η STL να περιέχει στοιχεία αντικειμενοστραφούς προγραμματισμού. Αυτός είναι και ο λόγος που δεν μπορούμε να την χρησιμοποιήσουμε σε προγράμματα της C και τελικά, η STL γίνεται ο λόγος για τον οποίον χρησιμοποιούμε C++ και όχι C στους διαγωνισμούς. Αρκετά όμως με την C, ας επανέλθουμε στο θέμα μας.
Η STL μας παρέχει έτοιμες υλοποιημένες συναρτήσεις, με βασικότερη την συνάρτηση sort() που ταξινομεί πίνακες με βέλτιστη πολυπλοκότητα. Οι υπόλοιπες συναρτήσεις που περιέχει είναι απλές και εύκολες για να τις υλοποιήσουμε μόνοι μας, είναι απλά συντομεύσεις και δεν θα αναλυθούν. Θα αναφερθούν μόνο οι συναρτήσεις swap(), min() max(), prev(), next(), των οποίων η χρήση θα προτιμάται έναντι δικού μας κώδικα.
Εκτός όμως από συναρτήσεις, η STL παρέχει και έτοιμες δομές δεδομένων, η γνώση των οποίων είναι απαραίτητη. Έτσι κλείνει η εισαγωγή περι standard βιβλιοθηκών και ξεκινάει το ζουμί αυτού του κεφαλαίου.
## STL containers
Τα containers είναι κλάσεις σχεδιασμένες για να αποθηκεύουν δεδομένα. Για απλότητα μπορείς να θεωρήσεις ότι μια κλάση είναι ένα κατασκευαστικό σχέδιο, ένα καλούπι. Με βάση λοιπόν μια κλάση μπορούμε να φτιάξουμε ένα αντικείμενο. Για παράδειγμα, χρησιμοποιώντας την κλάση vector, θα φτιάξουμε ένα αντικείμενο τύπου vector, δηλαδή έναν πίνακα.
{% highlight c++ %}
#include <vector> //περιλαμβάνουμε την αντίστοιχη βιβλιοθήκη
using namespace std; //απαραίτητο

vector<int> pinakas;
{% endhighlight %}
Θα λέμε ότι ο pinakas είναι ένα αντικείμενο τύπου vector, η πιο απλά ο pinakas είναι ένα vector. Θα μελετήσουμε τα vector διεξοδικά στην επόμενη παράγραφο. Ο κάθε τύπος container απαιτεί διαφορετικές παραμέτρους για να δημιουργηθεί. Όπως βλέπουμε παραπάνω, ο vector χρειάζεται τον τύπο δεδομένων που θα κρατάει (int). Οι παράμετροι δηλώνονται εντός των <> και αν είναι περισσότεροι του ενός χωρίζονται με κόμματα.
Κάτι ακόμα που είναι σημαντικό και πρέπει να προσέξουμε είναι ότι δεν ορίσαμε το μέγεθος του πίνακα! Αυτό δεν είναι λάθος γιατί το vector και όλα τα υπόλοιπα containers με τα οποία θα ασχοληθούμε είναι δυναμικά, δηλαδή το μέγεθος τους αυξομειώνεται αυτόματα για να χωράνε όλα τα στοιχεία τους.
Τα containers έχουν σχεδιαστεί ώστε οι κοινές λειτουργίες τους να έχουν το ίδιο όνομα. Έτσι σε όλα τα container υπάρχει η λειτουργία size() που επιστρέφει το μέγεθος του container, δηλαδή τον αριθμό των στοιχείων που περιέχει. Για να χρησιμοποιήσουμε μια λειτουργία του container χρησιμοποιούμε τον τελεστή . όπως στο παράδειγμα:
{% highlight c++ %}
#include <set>
#include <vector>
#include <cstdio>

using namespace std;

set<int> empty;
vector<long double> full={90.009,12.32,8.65,20000.0}; //αρχικοποίηση

int main()
{
printf(“%d %d\n”,empty.size(),full.size());
// τυπώνει 0 4
empty = {1,2,3,4,5}; //εκχώρηση
printf(“%d\n”,empty.size()); // τυπώνει 5
}
{% endhighlight %}
Όπως βλέπουμε από το παραπάνω παράδειγμα, μπορούμε να αρχικοποιήσουμε ένα container χρησιμοποιώντας initializer lists. Το εκπληκτικό όμως είναι ότι μπορούμε να εκχωρήσουμε κατευθείαν δεδομένα στο container με τον τελεστή =, κάτι που απαγορευόταν στους απλούς πίνακες.
Κάθε container περιλαμβάνει την λειτουργία empty(), που επιστρέφει true αν το container είναι άδειο (δηλαδή έχει μέγεθος 0). Επίσης, κάθε container περιλαμβάνει την λειτουργία clear(), που διαγράφει όλα τα αποθηκευμένα στοιχεία, erase() που διαγράφει συγκεκριμένα στοιχεία και insert() ή push_front()/push_back() για την εισαγωγή στοιχείων.
#### iterators
Σε κάποια containers επιτρέπεται η απευθείας πρόσβαση σε στοιχείο με τον ίδιο ακριβώς τρόπο που γίνεται και στους απλούς πίνακες. Για ορισμένες λειτουργίες όμως, ή για containers που δεν επιτρέπουν την άμεση προσπέλαση υπάρχει ένας τύπος δεδομένων που ονομάζεται iterator και αποθηκεύει την θέση ενός στοιχείου σε ένα container. Το iterator είναι το ανάλογο ενός δείκτη στον μηχανισμό των απλών πινάκων. Για να δηλώνουμε ένα iterator θα χρησιμοποιούμε το keyword auto. Με την χρήση του auto απαιτείται ωστόσο η κατευθείαν αρχικοποίηση της μεταβλητής αλλιώς το πρόγραμμα δεν μεταγλωττίζεται. Κάθε container διαθέτει τις λειτουργίες begin() και end(). Η begin() επιστρέφει ένα iterator για το πρώτο στοιχείο του container, ενώ η end() για το υποθετικό στοιχείο που βρίσκεται μετά το τελευταίο.
{% highlight c++ %}
auto first=myvector.begin(), after_end=myvector.end();
{% endhighlight %}
Η μεταβλητή first είναι ένα iterator που δείχνει στο πρώτο στοιχείο και όχι το πρώτο στοιχείο. Για να πάρουμε την τιμή του πρώτου στοιχείου θα κάνουμε dereference τον iterator first:
{% highlight c++ %}
printf(“%d”,*first);
{% endhighlight %}
Προσοχή: απαγορεύεται να κάνουμε dereference το iterator after_end, επειδή πολύ απλά δεν δείχνει σε κάποιο υπαρκτό στοιχείο. Επίσης μερικά containers δεν επιτρέπουν την τροποποίηση στοιχείου μέσω των iterators! Αυτό σημαίνει ότι το παρακάτω δεν επιτρέπεται για όλα τα container:
{% highlight c++ %}
*first = 5; // compilation error αν δεν επιτρέπεται η τροποποίηση
{% endhighlight %}
Τα iterators είναι φτιαγμένα με βάση τους δείκτες. Έτσι μπορούμε ακόμα να προχωρήσουμε ένα iterator ώστε να δείχνει στο επόμενο στοιχείο με τον τελεστή ++. Ομοίως μπορούμε να χρησιμοποιήσουμε τον τελεστή --:
{% highlight c++ %}
first++;
++first;
first--;
--first;
{% endhighlight %}
Για την θέση του ++ και του – ισχύουν οι γνωστοί κανόνες. Αν πάλι θέλουμε να πάρουμε ένα iterator που δείχνει στο επόμενο ή στο προηγούμενο στοιχείο, χωρίς όμως να προχωρήσουμε το iterator που έχουμε χρησιμοποιούμε τις συναρτήσεις prev() και next().
{% highlight c++ %}
printf(“%d %d\n”,*next(first),*prev(last));
// τυπώνει το 2ο και το τελευταίο στοιχείο του container
{% endhighlight %}
Το γεγονός ότι η λειτουργία end() επιστρέφει ένα μη έγκυρο iterator αποτελεί μια πολύ συχνή αιτία σφαλμάτων όταν δουλεύουμε με την STL. Θα δούμε όμως παρακάτω ότι τα containers είναι πλήρως εναρμονισμένα με τους υλοποιημένους αλγόριθμους σε μορφή συναρτήσεων που περιέχει η STL.
Για να προσπελάσουμε κάθε στοιχείο ενός container, αρκεί να ορίσουμε έναν iterator με την τιμή begin() και να τον προχωράμε βήμα βήμα μέχρι να πετύχουμε το στοιχείο end(). Αυτό γίνεται εύκολα με ένα loop
{% highlight c++ %}
for (auto it=myvector.begin(); it!=myvector.end(); it++)
	printf(“%d”,*it);
{% endhighlight  %}
Το παραπάνω μπορεί να γραφτεί και πιο σύντομα:
{% highlight c++ %}
for (auto it:myvector)
	printf(“%d”,it);
{% endhighlight %}
Στην πρώτη περίπτωση όμως το it είναι ένας iterator, επομένως απαιτείται η χρήση του τελεστή * για να παίρνουμε την τιμή στου στοιχείου μέσα στο loop. Στην δεύτερη περίπτωση, το it είναι μια μεταβλητή στην οποία εκχωρούνται διαδοχικά τα στοιχεία του myvector, οπότε δεν βάζουμε τελεστή *.
Το vector επιτρέπει την τροποποίηση των στοιχείων του, οπότε θα μπορούσαμε να χρησιμοποιήσουμε τον iterator για να εκχωρήσουμε μία άλλη τιμή στην θέση στην οποία δείχνει.
{% highlight c++ %}
for (auto it=myvector.begin(); it!=myvector.end(); it++)
{
printf(“%d”,*it);
*it=0;
}
{% endhighlight %}
Αυτό όμως δεν δουλεύει στην δεύτερη περίπτωση, γιατί όπως είπαμε στην μεταβλητή it εκχωρούνται διαδοχικά όλα τα στοιχεία του myvector. Δηλαδή η μεταβλητή it είναι ένα αντίγραφο του εκάστοτε στοιχείου, οπότε μια εκχώρηση θα επηρέαζε μόνο την it και όχι τα στοιχεία του myvector. Αν θέλουμε να επηρεάζονται και τα στοιχεία του myvector θα χρησιμοποιήσουμε μια αναφορά:
{% highlight c++ %}
for (auto &it:myvector)
{
printf(“%d\n”,it);
it=0;
}
// το myvector έχει μηδενιστεί
{% endhighlight %}
## pair
Η πιο απλή δεδομένων που υπάρχει στην STL είναι το pair. Ουσιαστικά είναι ένα ζευγάρι μεταβλητών οποιουδήποτε τύπου. Για να τα χρησιμοποιήσουμε πρέπει να συμπεριλάβουμε το αρχείο vector ή το αρχείο algorithm. Για την δήλωση τους απαιτούνται ως παράμετροι οι τύποι των δύο μεταβλητών, ενώ μπορούμε να τα αρχικοποιήσουμε με δύο τρόπους.
{% highlight c++ %}
pair<long long,char> pair1 = {23232121212121,’f’};
pair<int,int> pair2(5,10);
{% endhighlight %}
Για να προσπελάσουμε(εγγράψουμε ή αναγνώσουμε) το πρώτο στοιχείο χρησιμοποιούμε το πεδίο first του pair, ενώ για το δεύτερο το second. Προσοχή, τα first και second δεν είναι λειτουργίες και για αυτό δεν συντάσσονται με παρενθέσεις.
{% highlight c++ %}
pair1.first=0;
pair1.second=’a’;
{% endhighlight %}
Μπορούμε να συγκρίνουμε δύο pairs που έχουν μεταβλητές του ίδιου τύπου με τους τελεστές ==, !=, <, <=, > , >=. Κατά την σύγκριση αρχικά λαμβάνονται υπόψη μόνο τα πεδία first. Αν τα δύο πεδία είναι ίσα, τότε συγκρίνονται τα πεδία second, αλλιώς επιστρέφεται το αποτέλεσμα της σύγκρισης για τα πεδία first.
## Πλεονεκτήματα και μειονεκτήματα των containers της STL
Πράγματι η STL είναι ο λόγος που χρησιμοποιούμε την C++ και όχι την C στους διαγωνισμούς. Από αυτήν θα χρησιμοποιήσουμε έτοιμους αλγόριθμους και container, ορισμένα από τα οποία θα ήταν εξαιρετικά δύσκολο και χρονοβόρο να τα υλοποιήσουμε μόνοι μας την ώρα του διαγωνισμού. Ορισμένα από αυτά μάλιστα απαιτούν και πολύ προχωρημένες γνώσεις για την υλοποίηση τους. Σε άλλες περιπτώσεις χρησιμοποιούμε την STL για λόγους ευκολίας. Ωστόσο τα μειονεκτήματα της STL είναι δυο:
•	Το πρόγραμμα γίνεται πιο αργό (σε χρόνο εκτέλεσης)
•	Είναι εύκολο να κάνουμε λάθη
Από τα παραπάνω συμπεραίνουμε ότι πρέπει να χρησιμοποιούμε την STL με φειδώ. Δηλαδή να την αποφεύγουμε για απλές εφαρμογές που μπορούμε να υλοποιήσουμε εύκολα με το συναρτησιακό κομμάτι της C++, αλλά να την χρησιμοποιούμε για να κερδίζουμε χρόνο και να παρακάμπτουμε την υλοποίηση δύσκολων αλγορίθμων και δομών δεδομένων.
